<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Quality 3D Avatar Body Tracking Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            overflow: hidden;
            color: white;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* –í–∏–¥–µ–æ —Å–∫—Ä—ã—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ */
        #videoElement {
            position: absolute;
            top: -9999px;
            left: -9999px;
            width: 640px;
            height: 480px;
        }

        /* –ö–∞–Ω–≤–∞—Å –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ */
        #gameCanvas {
            flex: 1;
            background: rgba(0, 0, 0, 0.1);
            cursor: none;
        }

        /* UI —ç–ª–µ–º–µ–Ω—Ç—ã */
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            min-width: 300px;
            font-size: 16px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 25px;
            backdrop-filter: blur(20px);
            max-width: 600px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        }

        .mega-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24, #ff9ff3, #54a0ff);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
            color: white;
            border: none;
            padding: 18px 36px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 15px;
            transition: all 0.4s ease;
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mega-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.7);
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        .status-active { background: #4CAF50; }
        .status-warning { background: #FF9800; }
        .status-error { background: #f44336; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        .mega-spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.1);
            border-top: 8px solid #ff6b6b;
            border-radius: 50%;
            animation: megaSpin 1s linear infinite;
        }

        @keyframes megaSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            pointer-events: none;
            animation: particleExplode 1.5s ease-out forwards;
            z-index: 50;
        }

        @keyframes particleExplode {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.3) translateY(-150px) rotate(360deg);
            }
        }

        .score-display {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .combo-display {
            font-size: 24px;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <video id="videoElement" autoplay muted playsinline></video>
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameUI">
            <div class="score-display">–û—á–∫–∏: <span id="scoreValue">0</span></div>
            <div class="combo-display">–ö–æ–º–±–æ: x<span id="comboValue">1</span></div>
            <div style="margin-top: 15px;">
                <span class="status-indicator status-error" id="trackingIndicator"></span>
                <span id="trackingStatus">–¢—Ä–µ–∫–∏–Ω–≥: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è</span>
            </div>
            <div style="margin-top: 10px; font-size: 14px;">
                FPS: <span id="fpsDisplay">0</span>
            </div>
        </div>

        <div id="instructions">
            <h1>üéÆ MEGA 3D AVATAR TRACKING GAME</h1>
            <h2>‚ú® –ú–µ–≥–∞ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∏–≥—Ä–∞ —Å –ø–æ–ª–Ω—ã–º —Ç—Ä–µ–∫–∏–Ω–≥–æ–º —Ç–µ–ª–∞ ‚ú®</h2>
            <p style="margin: 20px 0; font-size: 18px; line-height: 1.6;">
                üéØ –ü–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ—É—Ç–±—É–∫ —Ç–∞–∫, —á—Ç–æ–±—ã –≤—Å—ë —Ç–µ–ª–æ –±—ã–ª–æ –≤–∏–¥–Ω–æ<br>
                üéØ –£–ø—Ä–∞–≤–ª—è–π—Ç–µ –º–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–º 3D –∞–≤–∞—Ç–∞—Ä–æ–º —Ç–µ–ª–æ–º<br>
                üéØ –°–æ–±–∏—Ä–∞–π—Ç–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã –∏ —É–∫–ª–æ–Ω—è–π—Ç–µ—Å—å –æ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π<br>
                üéØ –§–æ–Ω —É–¥–∞–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ - —Ç–æ–ª—å–∫–æ –∞–≤–∞—Ç–∞—Ä!
            </p>
            <button class="mega-button" onclick="initializeGame()">üöÄ –ú–ï–ì–ê –ü–û–ì–ù–ê–õ–ò!</button>
            <button class="mega-button" onclick="testCamera()">üìπ –¢–µ—Å—Ç –∫–∞–º–µ—Ä—ã</button>
        </div>

        <div id="loadingScreen" class="loading-screen" style="display: none;">
            <div class="mega-spinner"></div>
            <h2 style="margin-top: 30px;">–ó–∞–≥—Ä—É–∑–∫–∞ –º–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π...</h2>
            <p id="loadingText">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π...</p>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.20.0/dist/tf-core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.20.0/dist/tf-converter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.20.0/dist/tf-backend-webgl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –º–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∏–≥—Ä—ã
        class MegaGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.getElementById('videoElement');
                
                // –ò–≥—Ä–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                this.score = 0;
                this.combo = 1;
                this.isRunning = false;
                this.lastTime = 0;
                this.fps = 0;
                this.frameCount = 0;
                
                // AI –º–æ–¥–µ–ª–∏
                this.poseDetector = null;
                this.segmenter = null;
                
                // –ò–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
                this.avatar = {
                    x: 0,
                    y: 0,
                    scale: 1,
                    rotation: 0,
                    keypoints: [],
                    visible: true
                };
                
                this.crystals = [];
                this.obstacles = [];
                this.particles = [];
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç—Ä–µ–∫–∏–Ω–≥–∞
                this.trackingQuality = 0;
                this.backgroundRemoved = true;
                
                this.setupCanvas();
                this.initializeModels();
            }
            
            setupCanvas() {
                const resizeCanvas = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            async initializeModels() {
                try {
                    this.showLoading('–ó–∞–≥—Ä—É–∑–∫–∞ MoveNet Lightning...');
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª—É—á—à—É—é –º–æ–¥–µ–ª—å —Å–æ–≥–ª–∞—Å–Ω–æ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è–º
                    this.poseDetector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        {
                            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                            enableSmoothing: true,
                            enableTracking: true
                        }
                    );
                    
                    this.showLoading('–ó–∞–≥—Ä—É–∑–∫–∞ Body Segmentation...');
                    
                    // –î–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞
                    this.segmenter = await bodySegmentation.createSegmenter(
                        bodySegmentation.SupportedModels.MediaPipeSelfieSegmentation,
                        {
                            runtime: 'mediapipe',
                            solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation',
                            modelType: 'general'
                        }
                    );
                    
                    this.showLoading('–ú–æ–¥–µ–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã! –ì–æ—Ç–æ–≤—ã –∫ –º–µ–≥–∞-–∏–≥—Ä–µ!');
                    
                    console.log('üöÄ –í—Å–µ –º–æ–¥–µ–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!');
                    
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π:', error);
                    this.updateStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π', 'error');
                }
            }
            
            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user',
                            frameRate: { ideal: 30 }
                        }
                    });
                    
                    this.video.srcObject = stream;
                    await new Promise(resolve => {
                        this.video.onloadedmetadata = resolve;
                    });
                    
                    this.updateStatus('–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞', 'active');
                    return true;
                    
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', error);
                    this.updateStatus('–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã', 'error');
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.');
                    return false;
                }
            }
            
            async detectPose() {
                if (!this.poseDetector || !this.video.readyState === 4) return null;
                
                try {
                    const poses = await this.poseDetector.estimatePoses(this.video);
                    return poses.length > 0 ? poses[0] : null;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –ø–æ–∑—ã:', error);
                    return null;
                }
            }
            
            async removeBackground() {
                if (!this.segmenter || !this.video.readyState === 4) return null;
                
                try {
                    const segmentation = await this.segmenter.segmentPeople(this.video);
                    return segmentation;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞:', error);
                    return null;
                }
            }
            
            updateAvatar(pose) {
                if (!pose || !pose.keypoints) return;
                
                this.avatar.keypoints = pose.keypoints;
                
                // –ù–∞—Ö–æ–¥–∏–º —Ü–µ–Ω—Ç—Ä —Ç–µ–ª–∞ –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∞–≤–∞—Ç–∞—Ä–∞
                const nose = pose.keypoints.find(kp => kp.name === 'nose');
                const leftHip = pose.keypoints.find(kp => kp.name === 'left_hip');
                const rightHip = pose.keypoints.find(kp => kp.name === 'right_hip');
                
                if (nose && leftHip && rightHip) {
                    const centerX = (leftHip.x + rightHip.x) / 2;
                    const centerY = (nose.y + leftHip.y + rightHip.y) / 3;
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã canvas
                    this.avatar.x = (centerX / this.video.videoWidth) * this.canvas.width;
                    this.avatar.y = (centerY / this.video.videoHeight) * this.canvas.height;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–º–µ—Ä–∞ —Ç–µ–ª–∞
                    const bodyHeight = Math.abs(nose.y - (leftHip.y + rightHip.y) / 2);
                    this.avatar.scale = Math.max(0.5, Math.min(2, bodyHeight / this.video.videoHeight * 3));
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ —Ç—Ä–µ–∫–∏–Ω–≥–∞
                const visibleKeypoints = pose.keypoints.filter(kp => kp.score > 0.3).length;
                this.trackingQuality = visibleKeypoints / pose.keypoints.length;
                
                if (this.trackingQuality > 0.7) {
                    this.updateStatus('–ú–µ–≥–∞-—Ç—Ä–µ–∫–∏–Ω–≥ –∞–∫—Ç–∏–≤–µ–Ω!', 'active');
                } else if (this.trackingQuality > 0.4) {
                    this.updateStatus('–¢—Ä–µ–∫–∏–Ω–≥ —Ä–∞–±–æ—Ç–∞–µ—Ç', 'warning');
                } else {
                    this.updateStatus('–°–ª–∞–±—ã–π —Ç—Ä–µ–∫–∏–Ω–≥', 'error');
                }
            }
            
            drawMegaAvatar() {
                if (!this.avatar.keypoints.length) return;
                
                const ctx = this.ctx;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ canvas
                ctx.save();
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                ctx.translate(this.avatar.x, this.avatar.y);
                ctx.scale(this.avatar.scale, this.avatar.scale);
                ctx.rotate(this.avatar.rotation);
                
                // –†–∏—Å—É–µ–º –º–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∞–≤–∞—Ç–∞—Ä–∞
                this.drawAvatarBody();
                this.drawAvatarKeypoints();
                this.drawAvatarConnections();
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ canvas
                ctx.restore();
            }
            
            drawAvatarBody() {
                const ctx = this.ctx;
                
                // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Ç–µ–ª–∞
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 100);
                gradient.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(50, 150, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(0, 100, 200, 0.4)');
                
                // –†–∏—Å—É–µ–º –æ—Å–Ω–æ–≤—É –∞–≤–∞—Ç–∞—Ä–∞
                ctx.fillStyle = gradient;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.ellipse(0, 0, 60, 100, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            drawAvatarKeypoints() {
                const ctx = this.ctx;
                
                this.avatar.keypoints.forEach((keypoint, index) => {
                    if (keypoint.score < 0.3) return;
                    
                    const x = (keypoint.x / this.video.videoWidth - 0.5) * 200;
                    const y = (keypoint.y / this.video.videoHeight - 0.5) * 300;
                    
                    // –ú–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–æ—á–∫–∏ —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
                    const pointGradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
                    pointGradient.addColorStop(0, '#ffff00');
                    pointGradient.addColorStop(0.5, '#ff6b6b');
                    pointGradient.addColorStop(1, '#4ecdc4');
                    
                    ctx.fillStyle = pointGradient;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–π —ç—Ñ—Ñ–µ–∫—Ç
                    const pulse = Math.sin(Date.now() * 0.01 + index) * 0.5 + 0.5;
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10 + pulse * 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }
            
            drawAvatarConnections() {
                const ctx = this.ctx;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–æ—Å—Ç–µ–π
                const connections = [
                    ['left_shoulder', 'right_shoulder'],
                    ['left_shoulder', 'left_elbow'],
                    ['left_elbow', 'left_wrist'],
                    ['right_shoulder', 'right_elbow'],
                    ['right_elbow', 'right_wrist'],
                    ['left_hip', 'right_hip'],
                    ['left_hip', 'left_knee'],
                    ['left_knee', 'left_ankle'],
                    ['right_hip', 'right_knee'],
                    ['right_knee', 'right_ankle'],
                    ['left_shoulder', 'left_hip'],
                    ['right_shoulder', 'right_hip']
                ];
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                connections.forEach(([startName, endName]) => {
                    const start = this.avatar.keypoints.find(kp => kp.name === startName);
                    const end = this.avatar.keypoints.find(kp => kp.name === endName);
                    
                    if (start && end && start.score > 0.3 && end.score > 0.3) {
                        const x1 = (start.x / this.video.videoWidth - 0.5) * 200;
                        const y1 = (start.y / this.video.videoHeight - 0.5) * 300;
                        const x2 = (end.x / this.video.videoWidth - 0.5) * 200;
                        const y2 = (end.y / this.video.videoHeight - 0.5) * 300;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
            }
            
            updateGameObjects() {
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
                this.crystals.forEach((crystal, index) => {
                    crystal.rotation += 0.05;
                    crystal.scale = 1 + Math.sin(Date.now() * 0.005 + index) * 0.2;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏—é —Å –∞–≤–∞—Ç–∞—Ä–æ–º
                    const distance = Math.sqrt(
                        Math.pow(crystal.x - this.avatar.x, 2) + 
                        Math.pow(crystal.y - this.avatar.y, 2)
                    );
                    
                    if (distance < 50) {
                        this.collectCrystal(index);
                    }
                });
                
                // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
                if (this.crystals.length < 5 && Math.random() < 0.02) {
                    this.createCrystal();
                }
            }
            
            createCrystal() {
                this.crystals.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    rotation: 0,
                    scale: 1,
                    type: Math.floor(Math.random() * 3)
                });
            }
            
            collectCrystal(index) {
                const crystal = this.crystals[index];
                this.score += 10 * this.combo;
                this.combo += 0.1;
                
                // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã
                this.createParticles(crystal.x, crystal.y);
                
                // –£–¥–∞–ª—è–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª
                this.crystals.splice(index, 1);
                
                this.updateScoreDisplay();
            }
            
            createParticles(x, y) {
                for (let i = 0; i < 12; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.animationDelay = Math.random() * 0.5 + 's';
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 1500);
                }
            }
            
            drawGameObjects() {
                const ctx = this.ctx;
                
                // –†–∏—Å—É–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
                this.crystals.forEach((crystal, index) => {
                    ctx.save();
                    ctx.translate(crystal.x, crystal.y);
                    ctx.rotate(crystal.rotation);
                    ctx.scale(crystal.scale, crystal.scale);
                    
                    const colors = ['#ffeb3b', '#ff9800', '#4caf50'];
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    gradient.addColorStop(0, colors[crystal.type]);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    
                    // –†–∏—Å—É–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª –∫–∞–∫ —Ä–æ–º–±
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(15, 0);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(-15, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }
            
            drawBackground() {
                const ctx = this.ctx;
                
                // –°–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–æ–Ω
                const time = Date.now() * 0.001;
                const gradient = ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, `hsl(${time * 20}, 70%, 20%)`);
                gradient.addColorStop(0.5, `hsl(${time * 20 + 60}, 70%, 15%)`);
                gradient.addColorStop(1, `hsl(${time * 20 + 120}, 70%, 25%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∑–≤–µ–∑–¥—ã
                for (let i = 0; i < 50; i++) {
                    const x = (Math.sin(time * 0.1 + i) * 100 + this.canvas.width / 2 + i * 50) % this.canvas.width;
                    const y = (Math.cos(time * 0.15 + i) * 50 + this.canvas.height / 2 + i * 30) % this.canvas.height;
                    const opacity = Math.sin(time * 2 + i) * 0.5 + 0.5;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            calculateFPS(currentTime) {
                this.frameCount++;
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                    document.getElementById('fpsDisplay').textContent = this.fps;
                }
            }
            
            async gameLoop(currentTime) {
                if (!this.isRunning) return;
                
                this.calculateFPS(currentTime);
                
                // –î–µ—Ç–µ–∫—Ü–∏—è –ø–æ–∑—ã
                const pose = await this.detectPose();
                if (pose) {
                    this.updateAvatar(pose);
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
                if (this.backgroundRemoved) {
                    await this.removeBackground();
                }
                
                // –û—á–∏—â–∞–µ–º canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –†–∏—Å—É–µ–º –∏–≥—Ä—É
                this.drawBackground();
                this.updateGameObjects();
                this.drawGameObjects();
                this.drawMegaAvatar();
                
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ü–∏–∫–ª
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            updateStatus(message, type) {
                const statusElement = document.getElementById('trackingStatus');
                const indicator = document.getElementById('trackingIndicator');
                
                statusElement.textContent = `–¢—Ä–µ–∫–∏–Ω–≥: ${message}`;
                indicator.className = `status-indicator status-${type}`;
            }
            
            updateScoreDisplay() {
                document.getElementById('scoreValue').textContent = Math.floor(this.score);
                document.getElementById('comboValue').textContent = this.combo.toFixed(1);
            }
            
            showLoading(text) {
                document.getElementById('loadingScreen').style.display = 'flex';
                document.getElementById('loadingText').textContent = text;
            }
            
            hideLoading() {
                document.getElementById('loadingScreen').style.display = 'none';
            }
            
            async start() {
                if (!this.poseDetector || !this.segmenter) {
                    alert('–ú–æ–¥–µ–ª–∏ –µ—â–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.');
                    return;
                }
                
                this.showLoading('–ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã...');
                const cameraStarted = await this.startCamera();
                
                if (!cameraStarted) {
                    this.hideLoading();
                    return;
                }
                
                // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
                for (let i = 0; i < 3; i++) {
                    this.createCrystal();
                }
                
                this.hideLoading();
                document.getElementById('instructions').style.display = 'none';
                this.isRunning = true;
                
                this.updateStatus('–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ!', 'active');
                this.gameLoop(0);
            }
        }
        
        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∏–≥—Ä—ã
        const megaGame = new MegaGame();
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫
        async function initializeGame() {
            await megaGame.start();
        }
        
        async function testCamera() {
            const success = await megaGame.startCamera();
            if (success) {
                alert('–ö–∞–º–µ—Ä–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É.');
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            megaGame.setupCanvas();
        });
        
        console.log('üöÄ –ú–ï–ì–ê-–ö–ê–ß–ï–°–¢–í–ï–ù–ù–ê–Ø –ò–ì–†–ê –ì–û–¢–û–í–ê –ö –ó–ê–ü–£–°–ö–£!');
    </script>
</body>
</html>
