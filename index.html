<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>⚡ Ultra FPS — single‑file demo</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0a0b10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, 'Helvetica Neue', Arial, 'Apple Color Emoji', 'Segoe UI Emoji'; }
    #overlay { position: fixed; inset: 0; display: grid; place-items: center; background: radial-gradient(1200px 800px at 50% 30%, rgba(0,0,0,.5), #05060a 70%); color: #e6e9f5; z-index: 9999; }
    #panel { width: min(720px, 92vw); padding: 28px; border-radius: 16px; background: rgba(12,14,22,.8); backdrop-filter: blur(6px); box-shadow: 0 30px 80px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.05); }
    #panel h1 { margin: 0 0 8px; font-weight: 700; letter-spacing: .3px; }
    #panel p { margin: 6px 0; opacity: .9; line-height: 1.4; }
    #panel code { padding: 2px 6px; border-radius: 6px; background: rgba(255,255,255,.06); }
    #start { margin-top: 14px; padding: 14px 20px; border: 0; border-radius: 12px; font-weight: 700; font-size: 16px; cursor: pointer; color: #0b0e16; background: linear-gradient(180deg,#5cf,#39f); box-shadow: 0 8px 30px rgba(80,160,255,.45); }
    #start:active { transform: translateY(1px); }

    #hud { position: fixed; inset: 0; pointer-events: none; color: #e6e9f5; font-weight: 600; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
    #stats { position: absolute; left: 18px; bottom: 14px; font-size: 14px; opacity: .95; }
    #stats span { display: inline-block; min-width: 64px; }
    #wave { position: absolute; right: 18px; bottom: 14px; font-size: 14px; opacity: .95; }

    #crosshair { position: absolute; left: 50%; top: 50%; width: 16px; height: 16px; transform: translate(-50%,-50%); }
    #crosshair::before, #crosshair::after { content: ""; position: absolute; left: 50%; top: 50%; width: 2px; height: 14px; background: #e6e9f5; border-radius: 1px; opacity: .75; transform: translate(-50%,-50%); }
    #crosshair::after { transform: translate(-50%,-50%) rotate(90deg); }

    #message { position: absolute; top: 18px; left: 50%; transform: translateX(-50%); font-size: 14px; opacity: .85; }
    #hitmarker { position: absolute; left: 50%; top: 50%; width: 8px; height: 8px; border: 2px solid #fffb; border-radius: 50%; transform: translate(-50%,-50%) scale(0); opacity: 0; transition: transform .08s ease, opacity .2s ease; }
    #hitmarker.active { transform: translate(-50%,-50%) scale(1); opacity: 1; }

    .toast { position: absolute; right: 18px; top: 18px; padding: 10px 14px; border-radius: 10px; background: rgba(255,255,255,.08); box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }

    /* Mobile helpers */
    #touch { position: fixed; inset: 0; display: none; pointer-events: none; }
    .btn { position: absolute; width: 74px; height: 74px; border-radius: 50%; background: rgba(255,255,255,.08); box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); pointer-events: auto; }
    #fireBtn { right: 24px; bottom: 24px; }
    #jumpBtn { right: 110px; bottom: 84px; }
    #joy { left: 18px; bottom: 18px; width: 120px; height: 120px; border-radius: 60px; background: rgba(255,255,255,.06); }
    #knob { position: absolute; left: 36px; top: 36px; width: 48px; height: 48px; border-radius: 50%; background: rgba(255,255,255,.14); }

    canvas { display: block; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="panel">
      <h1>Ultra FPS — демо в одном файле</h1>
      <p>Шутер от 1‑го лица с освещением, тенями, пост‑эффектами, озвучкой (TTS), стрельбой, врагами, здоровьем, перезарядкой, попаданиями и частицами.</p>
      <p><strong>Управление:</strong> <code>WASD</code> — движение, <code>Мышь</code> — прицел, <code>ЛКМ</code> — огонь, <code>Space</code> — прыжок, <code>Shift</code> — бег, <code>R</code> — перезарядка, <code>P</code> — пауза.</p>
      <p>Работает через <strong>HTTPS или localhost</strong>. Аудио и Pointer Lock запускаются строго из клика (политики браузеров).</p>
      <button id="start">▶ Играть</button>
      <p style="margin-top:10px;opacity:.7">Если курсор не пропадает — кликните по центру экрана.</p>
    </div>
  </div>

  <div id="hud" hidden>
    <div id="message">Готово к бою</div>
    <div id="crosshair"></div>
    <div id="hitmarker"></div>
    <div id="stats"><span>HP: <b id="hp">100</b></span> <span>AMMO: <b id="ammo">12/120</b></span> <span>FPS: <b id="fps">0</b></span></div>
    <div id="wave">Волна: <b id="waveNum">1</b> | Врагов: <b id="left">0</b></div>
    <div class="toast" id="toast" hidden>Пауза — нажмите P</div>
  </div>

  <div id="touch">
    <div id="joy"></div>
    <div id="knob"></div>
    <div class="btn" id="fireBtn"></div>
    <div class="btn" id="jumpBtn"></div>
  </div>

  <script type="module">
    // ===== Imports (Three.js + post-processing) =====
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'https://unpkg.com/three@0.160.0/examples/jsm/shaders/FXAAShader.js';

    // ===== DOM refs =====
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start');
    const hud = document.getElementById('hud');
    const hpEl = document.getElementById('hp');
    const ammoEl = document.getElementById('ammo');
    const fpsEl = document.getElementById('fps');
    const waveEl = document.getElementById('waveNum');
    const leftEl = document.getElementById('left');
    const messageEl = document.getElementById('message');
    const hitmarker = document.getElementById('hitmarker');
    const toast = document.getElementById('toast');

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (isMobile) document.getElementById('touch').style.display = 'block';

    // ===== Audio (WebAudio + tiny synth) =====
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const makeGunshot = () => {
      // Procedural gunshot: short noise burst + low sine thump + filter
      const dur = .12;
      const noise = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
      const data = noise.getChannelData(0);
      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1 - i/data.length, 2.2); }
      const noiseSrc = audioCtx.createBufferSource(); noiseSrc.buffer = noise;
      const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type='bandpass'; noiseFilter.frequency.value=2400;
      const gain = audioCtx.createGain(); gain.gain.value = .9;
      const comp = audioCtx.createDynamicsCompressor();
      noiseSrc.connect(noiseFilter).connect(gain).connect(comp).connect(audioCtx.destination);

      const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.setValueAtTime(120, audioCtx.currentTime);
      const oGain = audioCtx.createGain(); oGain.gain.setValueAtTime(.7, audioCtx.currentTime);
      oGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      osc.connect(oGain).connect(comp);
      comp.connect(audioCtx.destination);

      noiseSrc.start(); noiseSrc.stop(audioCtx.currentTime + dur);
      osc.start(); osc.stop(audioCtx.currentTime + dur);
    };
    const makeHit = () => { const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=900; g.gain.value=.3; o.connect(g).connect(audioCtx.destination); o.frequency.exponentialRampToValueAtTime(180, audioCtx.currentTime+.08); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+.1); o.start(); o.stop(audioCtx.currentTime+.12); };
    const speak = (text) => { try { const u = new SpeechSynthesisUtterance(text); u.lang = 'ru-RU'; u.rate = 1.02; speechSynthesis.cancel(); speechSynthesis.speak(u);} catch(e){} };

    // ===== Three.js core =====
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0b10);

    // Subtle fog for atmosphere
    scene.fog = new THREE.Fog(0x0a0b10, 18, 120);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0, 1.7, 0);

    const controls = new PointerLockControls(camera, renderer.domElement);

    // Post‑processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const fxaa = new ShaderPass(FXAAShader);
    const px = 1 / (window.innerWidth * renderer.getPixelRatio());
    fxaa.material.uniforms['resolution'].value.set(px, px);
    composer.addPass(fxaa);
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.9, 0.85);
    composer.addPass(bloom);

    // Lights
    const hemi = new THREE.HemisphereLight(0x546cff, 0x101015, .35); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(12, 18, 6); dir.castShadow = true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(400, 400);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x20242e, metalness: .2, roughness: .9 });
    const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    // Simple arena walls
    const walls = [];
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x2a2f3b, metalness:.1, roughness:.8 });
    const makeWall = (x,y,z, sx,sy,sz) => { const m = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), wallMat); m.position.set(x,y,z); m.castShadow = m.receiveShadow = true; scene.add(m); walls.push(m); };
    // Perimeter & some obstacles
    const W=60, H=8, T=2;
    makeWall(0,H/2,-W/2, W, H, T); makeWall(0,H/2,W/2, W, H, T); makeWall(-W/2,H/2,0, T, H, W); makeWall(W/2,H/2,0, T, H, W);
    for(let i=0;i<8;i++){ makeWall((Math.random()*2-1)*20, 2, (Math.random()*2-1)*20, 4+Math.random()*6, 4+Math.random()*4, 1+Math.random()*4); }

    // Decorative emissive pillars (bloom candy)
    const pMat = new THREE.MeshStandardMaterial({ color: 0x111215, emissive: 0x1e90ff, emissiveIntensity: 1.5, metalness:.8, roughness:.3 });
    for(let i=0;i<10;i++){ const m = new THREE.Mesh(new THREE.CylinderGeometry(.6, .6, 8, 16), pMat); m.position.set((Math.random()*2-1)*24, 4, (Math.random()*2-1)*24); m.castShadow=true; scene.add(m);}    

    // Player (collision capsule)
    const player = {
      hp: 100,
      speed: 7,
      sprint: 11,
      velocity: new THREE.Vector3(),
      onGround: false,
      height: 1.7,
      radius: 0.4,
      ammo: 12,
      reserve: 120,
      reloading: false
    };

    // Weapon (view model)
    const gun = new THREE.Group();
    const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.25,1.4), new THREE.MeshStandardMaterial({ color: 0x2c2f38, metalness:.7, roughness:.2 }));
    gunBody.position.set(0.3,-0.2,-0.8);
    gun.add(gunBody);
    const muzzle = new THREE.Mesh(new THREE.ConeGeometry(0.08,0.2,16), new THREE.MeshStandardMaterial({ color: 0xffc000, emissive: 0xffaa00, emissiveIntensity: 2, metalness:.2, roughness:.3 }));
    muzzle.rotation.x = Math.PI/2; muzzle.position.set(0.6,-0.22,-1.5); gun.add(muzzle);
    camera.add(gun); scene.add(camera);

    // Muzzle flash sprite
    const flashMat = new THREE.SpriteMaterial({ color: 0xffcc66, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending });
    const flash = new THREE.Sprite(flashMat); flash.scale.set(0.35,0.35,0.35); flash.position.copy(muzzle.position); gun.add(flash);

    // Bullet holes pool
    const bulletHoles = []; const holeGeo = new THREE.PlaneGeometry(0.22,0.22);
    const holeMat = new THREE.MeshBasicMaterial({ color: 0x111, side: THREE.DoubleSide });

    // Particles group
    const particles = new THREE.Group(); scene.add(particles);

    function spawnSparks(point, normal){
      const count = 8 + (Math.random()*6|0);
      for(let i=0;i<count;i++){
        const s = new THREE.Mesh(new THREE.SphereGeometry(0.02,6,6), new THREE.MeshBasicMaterial({ color: 0xffbb66 }));
        s.position.copy(point);
        const vel = normal.clone().multiplyScalar(2).add(new THREE.Vector3((Math.random()-.5)*2,(Math.random())*1.5,(Math.random()-.5)*2));
        particles.add(s);
        s.userData = { vel, life: .35 + Math.random()*.3 };
      }
    }

    // Enemies
    const enemies = [];
    function spawnEnemy(){
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 20, 16), new THREE.MeshStandardMaterial({ color: 0x9d2aff, metalness:.4, roughness:.4, emissive:0x200040, emissiveIntensity:.6 }));
      body.castShadow = true; body.receiveShadow = true;
      const angle = Math.random()*Math.PI*2, dist = 18 + Math.random()*18;
      body.position.set(Math.cos(angle)*dist, 0.5, Math.sin(angle)*dist);
      body.userData = { hp: 60, speed: 2.2 + Math.random()*0.8 };
      scene.add(body); enemies.push(body);
    }
    function killEnemy(e){ scene.remove(e); enemies.splice(enemies.indexOf(e),1); for(let i=0;i<10;i++){ spawnSparks(e.position, new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize()); } }

    // Waves
    let wave = 1; let enemiesLeft = 0;
    function startWave(){
      const count = 5 + wave*2; enemiesLeft = count; leftEl.textContent = enemiesLeft; waveEl.textContent = wave;
      for(let i=0;i<count;i++) spawnEnemy();
      speak(`Волна ${wave}. Уничтожьте цели.`);
    }

    // Raycaster for shooting
    const raycaster = new THREE.Raycaster();

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{ if(['KeyW','KeyA','KeyS','KeyD','Space','ShiftLeft','KeyR','KeyP'].includes(e.code)) e.preventDefault(); keys.add(e.code); if(e.code==='KeyP') togglePause(); if(e.code==='KeyR') reload(); });
    window.addEventListener('keyup', (e)=>{ keys.delete(e.code); });

    // Touch controls (simple virtual joystick)
    const joy = document.getElementById('joy');
    const knob = document.getElementById('knob');
    const fireBtn = document.getElementById('fireBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    let joyActive=false, joyVec={x:0,y:0};
    function pointer(ev, el, onMove){ const id = ev.pointerId; el.setPointerCapture(id); const r = el.getBoundingClientRect();
      const center = { x: r.left + r.width/2, y: r.top + r.height/2 };
      const move = (e)=>{ const dx = Math.max(-1, Math.min(1, (e.clientX-center.x)/(r.width/2))); const dy = Math.max(-1, Math.min(1, (e.clientY-center.y)/(r.height/2))); onMove(dx, dy); };
      const up = ()=>{ el.releasePointerCapture(id); onMove(0,0,true); el.removeEventListener('pointermove', move); el.removeEventListener('pointerup', up); };
      el.addEventListener('pointermove', move); el.addEventListener('pointerup', up);
    }
    if(isMobile){
      joy.addEventListener('pointerdown', (e)=>{ joyActive=true; pointer(e, joy, (dx,dy,up)=>{ joyVec.x=dx; joyVec.y=dy; knob.style.left=36+dx*40+'px'; knob.style.top=36+dy*40+'px'; if(up){ joyActive=false; knob.style.left='36px'; knob.style.top='36px'; } }); });
      fireBtn.addEventListener('pointerdown', ()=>{ shoot(); });
      jumpBtn.addEventListener('pointerdown', ()=>{ if(player.onGround) player.velocity.y = 5; });
    }

    // Movement & collisions
    const tmpBox = new THREE.Box3();
    function collides(pos){
      // Simple capsule vs AABB check by sampling around player radius
      for(const w of walls){
        tmpBox.setFromObject(w);
        const px = Math.max(tmpBox.min.x, Math.min(pos.x, tmpBox.max.x));
        const py = Math.max(tmpBox.min.y, Math.min(pos.y, tmpBox.max.y));
        const pz = Math.max(tmpBox.min.z, Math.min(pos.z, tmpBox.max.z));
        const dx = pos.x - px, dy = pos.y - py, dz = pos.z - pz;
        if (dx*dx + dy*dy + dz*dz < player.radius*player.radius) return true;
      }
      return false;
    }

    function movePlayer(delta){
      const speed = (keys.has('ShiftLeft') ? player.sprint : player.speed) * (isMobile ? 0.7 : 1);
      const dir = new THREE.Vector3();
      const forward = Number(keys.has('KeyW')) - Number(keys.has('KeyS'));
      const strafe = Number(keys.has('KeyD')) - Number(keys.has('KeyA'));
      dir.set(strafe, 0, forward);
      if(isMobile && (joyActive || Math.hypot(joyVec.x, joyVec.y)>.1)){
        dir.x += joyVec.x; dir.z -= joyVec.y;
      }
      if(dir.lengthSq()>0) dir.normalize();

      // Apply camera rotation to direction
      const quat = camera.quaternion.clone();
      const move = new THREE.Vector3(dir.x, 0, dir.z).applyQuaternion(quat);
      // Zero out vertical component
      move.y = 0; move.normalize();
      const accel = 30; // quick acceleration
      const targetVX = move.x * speed; const targetVZ = move.z * speed;
      player.velocity.x += (targetVX - player.velocity.x) * Math.min(1, delta*accel);
      player.velocity.z += (targetVZ - player.velocity.z) * Math.min(1, delta*accel);

      // Gravity
      player.velocity.y += (player.onGround ? 0 : -22) * delta;

      // Try move with collision response
      const pos = controls.getObject().position.clone();
      const next = pos.clone().addScaledVector(player.velocity, delta);

      // Ground plane at y = 0
      if(next.y < player.height){ next.y = player.height; player.velocity.y = 0; player.onGround = true; } else { player.onGround = false; }

      // X axis
      const tryX = pos.clone(); tryX.x = next.x; if(!collides(tryX)) pos.x = tryX.x; else player.velocity.x = 0;
      // Z axis
      const tryZ = pos.clone(); tryZ.z = next.z; if(!collides(tryZ)) pos.z = tryZ.z; else player.velocity.z = 0;
      // Y (handled by ground)
      controls.getObject().position.copy(pos);

      // Head bob + weapon sway
      const bob = (Math.hypot(player.velocity.x, player.velocity.z) > 0.2) ? 1 : 0;
      const t = performance.now()*0.002;
      gun.position.set(0.1 + Math.sin(t*8)*0.02*bob, -0.15 + Math.cos(t*12)*0.02*bob, 0);
      gun.rotation.set(-0.02 + Math.sin(t*6)*0.01*bob, Math.sin(t*7)*0.01*bob, 0);
    }

    function makeBulletHole(point, normal){
      const hole = new THREE.Mesh(holeGeo, holeMat);
      hole.position.copy(point);
      // Orient to surface normal
      const q = new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize());
      hole.quaternion.copy(q);
      hole.renderOrder = 999; hole.depthTest = false;
      scene.add(hole);
      bulletHoles.push({ mesh: hole, life: 8 });
    }

    let paused = false;
    function togglePause(){ paused = !paused; toast.hidden = !paused; if(paused){
        document.exitPointerLock?.(); speak('Пауза. Нажмите P чтобы продолжить.');
      } else { renderer.domElement.requestPointerLock(); speechSynthesis.cancel(); }
    }

    function reload(){
      if(player.reloading || player.ammo===12 || player.reserve===0) return;
      player.reloading = true; message('Перезарядка...'); speak('Перезарядка');
      setTimeout(()=>{
        const need = 12 - player.ammo; const give = Math.min(need, player.reserve);
        player.ammo += give; player.reserve -= give; updateAmmo(); player.reloading = false; message('Готово');
      }, 900);
    }

    function updateAmmo(){ ammoEl.textContent = `${player.ammo}/${player.reserve}`; }
    function updateHP(){ hpEl.textContent = `${player.hp}`; }
    function message(text){ messageEl.textContent = text; }

    function shoot(){
      if(paused || player.reloading) return;
      if(player.ammo<=0){ makeDry(); message('Пусто. Нажмите R'); speak('Патроны закончились'); return; }
      player.ammo--; updateAmmo();
      // Recoil animation
      gun.position.z -= 0.06; gun.rotation.x -= 0.05;
      flash.material.opacity = 1; flash.scale.set(0.6,0.6,0.6); setTimeout(()=>{ flash.material.opacity = 0; }, 40);
      makeGunshot();

      // Raycast
      raycaster.setFromCamera({x:0,y:0}, camera);
      const objects = [...enemies, ...walls];
      const hits = raycaster.intersectObjects(objects, false);
      if(hits.length){
        const hit = hits[0];
        hitmarker.classList.add('active'); setTimeout(()=>hitmarker.classList.remove('active'), 60);
        spawnSparks(hit.point, hit.face?.normal || new THREE.Vector3(0,1,0));
        if(enemies.includes(hit.object)){
          const e = hit.object; e.userData.hp -= 28 + Math.random()*10; makeHit();
          if(e.userData.hp <= 0){ killEnemy(e); enemiesLeft--; leftEl.textContent = enemiesLeft; if(enemiesLeft<=0){ wave++; startWave(); } }
        } else {
          makeBulletHole(hit.point, hit.face?.normal || new THREE.Vector3(0,1,0));
        }
      }
    }

    function makeDry(){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='square'; o.frequency.value=800; g.gain.value=.2; o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+.06); }

    // Enemy AI
    function updateEnemies(delta){
      const playerPos = controls.getObject().position;
      for(const e of enemies){
        const dir = playerPos.clone().sub(e.position); const dist = dir.length();
        if(dist>0.001){ dir.normalize(); e.position.addScaledVector(dir, e.userData.speed*delta); e.lookAt(playerPos.x, e.position.y, playerPos.z); }
        // Damage if close
        if(dist < 1.2){ if(Math.random()<0.8*delta){ player.hp = Math.max(0, player.hp - 4); updateHP(); if(player.hp===0) gameOver(); } }
      }
    }

    function gameOver(){ paused = true; speak('Вы погибли. Нажмите Играть, чтобы попробовать снова.');
      overlay.style.display='grid'; document.getElementById('panel').querySelector('h1').textContent='Поражение';
      document.getElementById('panel').querySelector('p').textContent='Но можно попробовать ещё раз — волны сброшены.';
    }

    // Animate
    let last = performance.now(); let acc = 0;
    function animate(){
      const now = performance.now(); const dt = (now - last)/1000; last = now; acc += dt; // fps meter
      if(acc>0.25){ fpsEl.textContent = (1/dt|0).toString(); acc = 0; }
      if(!paused){
        movePlayer(Math.min(dt, .05));
        updateEnemies(Math.min(dt, .05));
        // particles update
        for(let i=particles.children.length-1;i>=0;i--){ const p = particles.children[i]; p.userData.life -= dt; p.position.addScaledVector(p.userData.vel, dt); p.userData.vel.multiplyScalar(0.96); p.material.opacity = Math.max(0, p.userData?.life || 0); if(p.userData.life<=0){ particles.remove(p); } }
        // decay recoil
        gun.position.z += (0 - gun.position.z) * 0.2; gun.rotation.x += ( -0.02 - gun.rotation.x) * 0.2;
        // bullet holes fade
        for(let i=bulletHoles.length-1;i>=0;i--){ bulletHoles[i].life -= dt; if(bulletHoles[i].life<=0){ scene.remove(bulletHoles[i].mesh); bulletHoles.splice(i,1);} }
        composer.render();
      }
      requestAnimationFrame(animate);
    }

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      const px = 1 / (window.innerWidth * renderer.getPixelRatio()); fxaa.material.uniforms['resolution'].value.set(px, px);
      bloom.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start on click
    startBtn.addEventListener('click', async ()=>{
      try{
        await audioCtx.resume();
      }catch(e){}
      overlay.style.display = 'none'; hud.hidden = false; toast.hidden = true; paused = false;
      renderer.domElement.requestPointerLock();
      controls.lock();
      scene.add(controls.getObject());
      controls.getObject().position.set(0, player.height, 10);
      updateAmmo(); updateHP();
      speak('Добро пожаловать на арену. Удачи!');
      // First wave
      enemies.forEach(e=>scene.remove(e)); enemies.length=0; wave=1; startWave();
      animate();
    });

    // Shoot events
    renderer.domElement.addEventListener('pointerdown', (e)=>{ if(document.pointerLockElement === renderer.domElement) shoot(); });

    // Safety: unlock pointer to show pause toast
    document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement !== renderer.domElement) { paused = true; toast.hidden = false; } });

    // Prevent context menu on long press (mobile)
    window.addEventListener('contextmenu', e=> e.preventDefault());
  </script>
</body>
</html>
