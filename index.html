<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate 3D Avatar Body Tracking Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b69 100%);
            overflow: hidden;
            color: white;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoElement {
            position: absolute;
            top: -9999px;
            width: 640px;
            height: 480px;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            background: transparent;
            cursor: none;
        }

        /* UI —ç–ª–µ–º–µ–Ω—Ç—ã */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            min-width: 320px;
        }

        .score-text {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .status-row {
            display: flex;
            align-items: center;
            margin-top: 15px;
            font-size: 16px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        .status-active { background: #4CAF50; box-shadow: 0 0 10px #4CAF50; }
        .status-warning { background: #FF9800; box-shadow: 0 0 10px #FF9800; }
        .status-error { background: #f44336; box-shadow: 0 0 10px #f44336; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* –°—Ç–∞—Ä—Ç–æ–≤–æ–µ –º–µ–Ω—é */
        .start-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.92);
            padding: 50px;
            border-radius: 30px;
            backdrop-filter: blur(25px);
            border: 3px solid rgba(255, 255, 255, 0.2);
            max-width: 700px;
        }

        .start-button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            animation: gradientFlow 4s ease infinite;
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 35px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            margin: 15px;
            transition: all 0.4s ease;
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .start-button:hover {
            transform: translateY(-5px) scale(1.08);
            box-shadow: 0 20px 50px rgba(255, 107, 107, 0.8);
        }

        @keyframes gradientFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* –ß–∞—Å—Ç–∏—Ü—ã –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ */
        .game-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            pointer-events: none;
            animation: particleBurst 2s ease-out forwards;
            z-index: 50;
        }

        @keyframes particleBurst {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.2) translateY(-200px) rotate(720deg);
            }
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 300;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.1);
            border-top: 6px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <video id="videoElement" autoplay muted playsinline></video>
        <canvas id="mainCanvas"></canvas>
        
        <div class="ui-panel">
            <div class="score-text">–û–ß–ö–ò: <span id="scoreDisplay">0</span></div>
            <div style="font-size: 18px; margin-top: 10px; color: #ffeb3b;">
                –ö–û–ú–ë–û: x<span id="comboDisplay">1.0</span>
            </div>
            <div class="status-row">
                <div class="status-dot status-error" id="trackingDot"></div>
                <span id="trackingText">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</span>
            </div>
            <div class="status-row">
                <div class="status-dot status-error" id="cameraDot"></div>
                <span id="cameraText">–ö–∞–º–µ—Ä–∞: –û—Ç–∫–ª—é—á–µ–Ω–∞</span>
            </div>
            <div style="margin-top: 15px; font-size: 14px; opacity: 0.8;">
                FPS: <span id="fpsCounter">0</span>
            </div>
        </div>

        <div class="start-menu" id="startMenu">
            <h1 style="font-size: 36px; margin-bottom: 20px;">
                üéÆ ULTIMATE 3D AVATAR GAME
            </h1>
            <h2 style="color: #4ecdc4; margin-bottom: 30px;">
                –ú–µ–≥–∞-–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç—Ä–µ–∫–∏–Ω–≥ –≤—Å–µ–≥–æ —Ç–µ–ª–∞
            </h2>
            <p style="font-size: 18px; line-height: 1.8; margin-bottom: 30px;">
                üéØ –ü–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ—É—Ç–±—É–∫ —Ç–∞–∫, —á—Ç–æ–±—ã –≤—Å—ë —Ç–µ–ª–æ –ø–æ–ø–∞–¥–∞–ª–æ –≤ –∫–∞–¥—Ä<br>
                üéØ –£–ø—Ä–∞–≤–ª—è–π—Ç–µ 3D –∞–≤–∞—Ç–∞—Ä–æ–º –¥–≤–∏–∂–µ–Ω–∏—è–º–∏ —Å–≤–æ–µ–≥–æ —Ç–µ–ª–∞<br>
                üéØ –°–æ–±–∏—Ä–∞–π—Ç–µ —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã<br>
                üéØ –§–æ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è–µ—Ç—Å—è
            </p>
            <button class="start-button" onclick="startUltimateGame()">
                üöÄ –ó–ê–ü–£–°–¢–ò–¢–¨ –ò–ì–†–£
            </button>
            <button class="start-button" onclick="testCameraFunction()">
                üì∑ –ü–†–û–í–ï–†–ò–¢–¨ –ö–ê–ú–ï–†–£
            </button>
        </div>

        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <h3 style="margin-top: 30px;">–ó–∞–≥—Ä—É–∑–∫–∞ AI –º–æ–¥–µ–ª–µ–π...</h3>
            <p id="loadingStatus" style="margin-top: 10px; opacity: 0.8;">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</p>
        </div>

        <div class="error-message" id="errorMessage"></div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.js"></script>

    <script>
        // –ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –∏–≥—Ä—ã
        class UltimateBodyTrackingGame {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.getElementById('videoElement');
                
                // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
                this.isInitialized = false;
                this.isRunning = false;
                this.score = 0;
                this.combo = 1.0;
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                // AI –º–æ–¥–µ–ª–∏
                this.poseDetector = null;
                this.bodySegmenter = null;
                
                // –ò–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
                this.avatar = {
                    x: 0,
                    y: 0,
                    keypoints: [],
                    confidence: 0
                };
                
                this.crystals = [];
                this.particles = [];
                
                this.setupCanvas();
                this.initializeAI();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                };
                resize();
                window.addEventListener('resize', resize);
            }
            
            async initializeAI() {
                try {
                    this.showLoading('–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∏—Å—Ç–µ–º—ã —Ç—Ä–µ–∫–∏–Ω–≥–∞...');
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –ø–æ–∑
                    this.updateLoadingStatus('–ó–∞–≥—Ä—É–∑–∫–∞ MoveNet...');
                    this.poseDetector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        {
                            modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
                            enableSmoothing: true,
                        }
                    );
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏
                    this.updateLoadingStatus('–ó–∞–≥—Ä—É–∑–∫–∞ Body Segmentation...');
                    this.bodySegmenter = await bodySegmentation.createSegmenter(
                        bodySegmentation.SupportedModels.SelfieSegmentation,
                        {
                            runtime: 'tfjs'
                        }
                    );
                    
                    this.isInitialized = true;
                    this.hideLoading();
                    this.updateStatus('–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞!', 'active');
                    
                    console.log('‚úÖ AI –º–æ–¥–µ–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
                    
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ AI:', error);
                    this.showError('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ AI –º–æ–¥–µ–ª–µ–π: ' + error.message);
                    this.hideLoading();
                }
            }
            
            async startCamera() {
                try {
                    this.updateLoadingStatus('–ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã...');
                    
                    const constraints = {
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user',
                            frameRate: { ideal: 30 }
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.updateCameraStatus('–ö–∞–º–µ—Ä–∞: –ê–∫—Ç–∏–≤–Ω–∞', 'active');
                            resolve(true);
                        };
                    });
                    
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã:', error);
                    this.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.');
                    this.updateCameraStatus('–ö–∞–º–µ—Ä–∞: –û—à–∏–±–∫–∞', 'error');
                    return false;
                }
            }
            
            async detectPose() {
                if (!this.poseDetector || this.video.readyState !== 4) {
                    return null;
                }
                
                try {
                    const poses = await this.poseDetector.estimatePoses(this.video);
                    return poses.length > 0 ? poses[0] : null;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –ø–æ–∑—ã:', error);
                    return null;
                }
            }
            
            updateAvatar(pose) {
                if (!pose || !pose.keypoints) return;
                
                this.avatar.keypoints = pose.keypoints;
                this.avatar.confidence = pose.score || 0;
                
                // –ù–∞—Ö–æ–¥–∏–º —Ü–µ–Ω—Ç—Ä —Ç–µ–ª–∞
                const nose = pose.keypoints.find(kp => kp.name === 'nose');
                const leftHip = pose.keypoints.find(kp => kp.name === 'left_hip');
                const rightHip = pose.keypoints.find(kp => kp.name === 'right_hip');
                
                if (nose && leftHip && rightHip && nose.score > 0.3) {
                    const centerX = (leftHip.x + rightHip.x) / 2;
                    const centerY = (nose.y + leftHip.y + rightHip.y) / 3;
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                    this.avatar.x = (centerX / this.video.videoWidth) * this.canvas.width;
                    this.avatar.y = (centerY / this.video.videoHeight) * this.canvas.height;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ç—Ä–µ–∫–∏–Ω–≥–∞
                const visiblePoints = pose.keypoints.filter(kp => kp.score > 0.3).length;
                const quality = visiblePoints / pose.keypoints.length;
                
                if (quality > 0.7) {
                    this.updateStatus('–û—Ç–ª–∏—á–Ω—ã–π —Ç—Ä–µ–∫–∏–Ω–≥', 'active');
                } else if (quality > 0.4) {
                    this.updateStatus('–°—Ä–µ–¥–Ω–∏–π —Ç—Ä–µ–∫–∏–Ω–≥', 'warning');
                } else {
                    this.updateStatus('–°–ª–∞–±—ã–π —Ç—Ä–µ–∫–∏–Ω–≥', 'error');
                }
            }
            
            drawAvatar() {
                if (!this.avatar.keypoints.length) return;
                
                const ctx = this.ctx;
                
                // –†–∏—Å—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                this.drawSkeleton();
                
                // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏
                this.avatar.keypoints.forEach((keypoint, index) => {
                    if (keypoint.score < 0.3) return;
                    
                    const x = (keypoint.x / this.video.videoWidth) * this.canvas.width;
                    const y = (keypoint.y / this.video.videoHeight) * this.canvas.height;
                    
                    // –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–∏–≤—É—é —Ç–æ—á–∫—É
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 15);
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(0.5, '#ff6b6b');
                    gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 20;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }
            
            drawSkeleton() {
                const ctx = this.ctx;
                const connections = [
                    ['left_shoulder', 'right_shoulder'],
                    ['left_shoulder', 'left_elbow'],
                    ['left_elbow', 'left_wrist'],
                    ['right_shoulder', 'right_elbow'],
                    ['right_elbow', 'right_wrist'],
                    ['left_hip', 'right_hip'],
                    ['left_hip', 'left_knee'],
                    ['left_knee', 'left_ankle'],
                    ['right_hip', 'right_knee'],
                    ['right_knee', 'right_ankle'],
                    ['left_shoulder', 'left_hip'],
                    ['right_shoulder', 'right_hip'],
                    ['nose', 'left_shoulder'],
                    ['nose', 'right_shoulder']
                ];
                
                ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                connections.forEach(([start, end]) => {
                    const startPoint = this.avatar.keypoints.find(kp => kp.name === start);
                    const endPoint = this.avatar.keypoints.find(kp => kp.name === end);
                    
                    if (startPoint && endPoint && startPoint.score > 0.3 && endPoint.score > 0.3) {
                        const x1 = (startPoint.x / this.video.videoWidth) * this.canvas.width;
                        const y1 = (startPoint.y / this.video.videoHeight) * this.canvas.height;
                        const x2 = (endPoint.x / this.video.videoWidth) * this.canvas.width;
                        const y2 = (endPoint.y / this.video.videoHeight) * this.canvas.height;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
            }
            
            generateCrystals() {
                if (this.crystals.length < 5 && Math.random() < 0.03) {
                    this.crystals.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        rotation: 0,
                        scale: 1,
                        collected: false,
                        type: Math.floor(Math.random() * 3)
                    });
                }
            }
            
            updateCrystals() {
                this.crystals.forEach((crystal, index) => {
                    if (crystal.collected) return;
                    
                    crystal.rotation += 0.05;
                    crystal.scale = 1 + Math.sin(Date.now() * 0.003 + index) * 0.3;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏
                    const distance = Math.sqrt(
                        Math.pow(crystal.x - this.avatar.x, 2) + 
                        Math.pow(crystal.y - this.avatar.y, 2)
                    );
                    
                    if (distance < 60) {
                        this.collectCrystal(index);
                    }
                });
            }
            
            collectCrystal(index) {
                const crystal = this.crystals[index];
                crystal.collected = true;
                
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç
                this.score += Math.floor(10 * this.combo);
                this.combo = Math.min(this.combo + 0.1, 5.0);
                
                // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç
                this.createParticleExplosion(crystal.x, crystal.y);
                
                // –£–¥–∞–ª—è–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª
                setTimeout(() => {
                    this.crystals.splice(index, 1);
                }, 100);
                
                this.updateScoreDisplay();
            }
            
            drawCrystals() {
                const ctx = this.ctx;
                
                this.crystals.forEach(crystal => {
                    if (crystal.collected) return;
                    
                    ctx.save();
                    ctx.translate(crystal.x, crystal.y);
                    ctx.rotate(crystal.rotation);
                    ctx.scale(crystal.scale, crystal.scale);
                    
                    const colors = ['#ffeb3b', '#e91e63', '#00bcd4'];
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                    gradient.addColorStop(0, colors[crystal.type]);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    
                    // –†–∏—Å—É–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª
                    ctx.beginPath();
                    ctx.moveTo(0, -25);
                    ctx.lineTo(18, -8);
                    ctx.lineTo(18, 8);
                    ctx.lineTo(0, 25);
                    ctx.lineTo(-18, 8);
                    ctx.lineTo(-18, -8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }
            
            createParticleExplosion(x, y) {
                for (let i = 0; i < 15; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'game-particle';
                    particle.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
                    particle.style.top = (y + (Math.random() - 0.5) * 40) + 'px';
                    particle.style.animationDelay = (Math.random() * 0.3) + 's';
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 2000);
                }
            }
            
            drawBackground() {
                const ctx = this.ctx;
                const time = Date.now() * 0.001;
                
                // –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–æ–Ω
                const gradient = ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, `hsl(${time * 10}, 50%, 10%)`);
                gradient.addColorStop(0.5, `hsl(${time * 10 + 60}, 60%, 8%)`);
                gradient.addColorStop(1, `hsl(${time * 10 + 120}, 50%, 15%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∑–≤–µ–∑–¥—ã
                for (let i = 0; i < 100; i++) {
                    const x = (Math.sin(time * 0.05 + i) * 200 + this.canvas.width / 2 + i * 20) % this.canvas.width;
                    const y = (Math.cos(time * 0.08 + i) * 100 + this.canvas.height / 2 + i * 15) % this.canvas.height;
                    const alpha = Math.sin(time * 3 + i) * 0.5 + 0.5;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            calculateFPS() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                    document.getElementById('fpsCounter').textContent = this.fps;
                }
            }
            
            async gameLoop() {
                if (!this.isRunning) return;
                
                this.calculateFPS();
                
                // –î–µ—Ç–µ–∫—Ü–∏—è –ø–æ–∑—ã
                const pose = await this.detectPose();
                if (pose) {
                    this.updateAvatar(pose);
                }
                
                // –û—á–∏—Å—Ç–∫–∞ –∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–µ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawBackground();
                
                // –ò–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞
                this.generateCrystals();
                this.updateCrystals();
                this.drawCrystals();
                
                // –†–∏—Å—É–µ–º –∞–≤–∞—Ç–∞—Ä
                this.drawAvatar();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            async start() {
                if (!this.isInitialized) {
                    this.showError('–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≥—Ä—É–∑–∫–∏ AI –º–æ–¥–µ–ª–µ–π');
                    return;
                }
                
                this.showLoading('–ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã...');
                
                const cameraOK = await this.startCamera();
                if (!cameraOK) {
                    this.hideLoading();
                    return;
                }
                
                // –°–±—Ä–æ—Å –∏–≥—Ä–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                this.score = 0;
                this.combo = 1.0;
                this.crystals = [];
                this.updateScoreDisplay();
                
                // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
                for (let i = 0; i < 3; i++) {
                    this.crystals.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        rotation: 0,
                        scale: 1,
                        collected: false,
                        type: Math.floor(Math.random() * 3)
                    });
                }
                
                this.hideLoading();
                document.getElementById('startMenu').style.display = 'none';
                this.isRunning = true;
                
                this.gameLoop();
            }
            
            // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã UI
            showLoading(message = '–ó–∞–≥—Ä—É–∑–∫–∞...') {
                document.getElementById('loadingOverlay').style.display = 'flex';
                this.updateLoadingStatus(message);
            }
            
            hideLoading() {
                document.getElementById('loadingOverlay').style.display = 'none';
            }
            
            updateLoadingStatus(text) {
                document.getElementById('loadingStatus').textContent = text;
            }
            
            updateStatus(text, type) {
                document.getElementById('trackingText').textContent = `–¢—Ä–µ–∫–∏–Ω–≥: ${text}`;
                document.getElementById('trackingDot').className = `status-dot status-${type}`;
            }
            
            updateCameraStatus(text, type) {
                document.getElementById('cameraText').textContent = text;
                document.getElementById('cameraDot').className = `status-dot status-${type}`;
            }
            
            updateScoreDisplay() {
                document.getElementById('scoreDisplay').textContent = this.score;
                document.getElementById('comboDisplay').textContent = this.combo.toFixed(1);
            }
            
            showError(message) {
                const errorEl = document.getElementById('errorMessage');
                errorEl.textContent = message;
                errorEl.style.display = 'block';
                setTimeout(() => {
                    errorEl.style.display = 'none';
                }, 5000);
            }
        }
        
        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∏–≥—Ä—ã
        const game = new UltimateBodyTrackingGame();
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫
        async function startUltimateGame() {
            await game.start();
        }
        
        async function testCameraFunction() {
            const success = await game.startCamera();
            if (success) {
                alert('‚úÖ –ö–∞–º–µ—Ä–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ç–ª–∏—á–Ω–æ! –ú–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å–∫–∞—Ç—å –∏–≥—Ä—É.');
            }
        }
        
        console.log('üéÆ Ultimate Body Tracking Game –≥–æ—Ç–æ–≤–∞ –∫ –∑–∞–ø—É—Å–∫—É!');
    </script>
</body>
</html>
