<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Avatar Body Tracking Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none;
        }

        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #avatarCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
        }

        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
        }

        .button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }

        #score {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameStatus {
            margin-top: 10px;
            font-size: 18px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 2s ease-out forwards;
        }

        @keyframes particle-float {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translateY(-100px);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <video id="videoElement" autoplay muted playsinline></video>
        <canvas id="canvasElement"></canvas>
        <canvas id="avatarCanvas"></canvas>
        
        <div id="gameUI">
            <div id="score">–°—á—ë—Ç: 0</div>
            <div id="gameStatus">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</div>
            <div id="tracking">–¢—Ä–µ–∫–∏–Ω–≥: –û—Ç–∫–ª—é—á–µ–Ω</div>
        </div>

        <div id="instructions">
            <h2>üéÆ 3D Avatar Body Tracking Game</h2>
            <p>–†–∞—Å–ø–æ–ª–æ–∂–∏—Ç–µ –Ω–æ—É—Ç–±—É–∫ —Ç–∞–∫, —á—Ç–æ–±—ã –≤—Å—ë —Ç–µ–ª–æ –±—ã–ª–æ –≤–∏–¥–Ω–æ –≤ –∫–∞–º–µ—Ä–µ</p>
            <p>–£–ø—Ä–∞–≤–ª—è–π—Ç–µ –∞–≤–∞—Ç–∞—Ä–æ–º –¥–≤–∏–∂–µ–Ω–∏—è–º–∏ —Ç–µ–ª–∞</p>
            <p>–°–æ–±–∏—Ä–∞–π—Ç–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã –∏ —É–∫–ª–æ–Ω—è–π—Ç–µ—Å—å –æ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π</p>
            <button class="button" onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <button class="button" onclick="toggleCamera()">–¢–µ—Å—Ç –∫–∞–º–µ—Ä—ã</button>
        </div>

        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p style="margin-top: 20px;">–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–µ–π...</p>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.1"></script>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, avatar, mixer;
        let videoElement, canvasElement, avatarCanvas;
        let holistic, bodyPixNet;
        let gameRunning = false;
        let score = 0;
        let avatarPosition = { x: 0, y: 0, z: 0 };
        let gameObjects = [];
        let particles = [];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
            
            videoElement = document.getElementById('videoElement');
            canvasElement = document.getElementById('canvasElement');
            avatarCanvas = document.getElementById('avatarCanvas');

            await initThreeJS();
            await initBodyPix();
            await initMediaPipe();
            
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        async function initThreeJS() {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js...');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                canvas: avatarCanvas, 
                alpha: true,
                antialias: true 
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // –°–æ–∑–¥–∞–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞
            await createAvatar();
            
            camera.position.set(0, 1.6, 3);
            camera.lookAt(0, 1, 0);

            animate();
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ 3D –∞–≤–∞—Ç–∞—Ä–∞
        async function createAvatar() {
            console.log('–°–æ–∑–¥–∞–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞...');
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–≥–æ, –Ω–æ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∞–≤–∞—Ç–∞—Ä–∞
            const geometry = new THREE.CapsuleGeometry(0.3, 1.4, 8, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x00ff88,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            
            avatar = new THREE.Mesh(geometry, material);
            avatar.position.set(0, 0.7, 0);
            avatar.castShadow = true;
            scene.add(avatar);

            // –î–æ–±–∞–≤–ª—è–µ–º –≥–æ–ª–æ–≤—É
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffddaa,
                shininess: 50
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.6, 0);
            head.castShadow = true;
            scene.add(head);

            // –î–æ–±–∞–≤–ª—è–µ–º —Ä—É–∫–∏
            const armGeometry = new THREE.CapsuleGeometry(0.08, 0.6, 6, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffddaa });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 1.2, 0);
            leftArm.castShadow = true;
            scene.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 1.2, 0);
            rightArm.castShadow = true;
            scene.add(rightArm);

            // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –≤—Å–µ —á–∞—Å—Ç–∏ –∞–≤–∞—Ç–∞—Ä–∞
            avatar.userData = { head, leftArm, rightArm };
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è BodyPix –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞
        async function initBodyPix() {
            console.log('–ó–∞–≥—Ä—É–∑–∫–∞ BodyPix...');
            document.getElementById('loading').style.display = 'block';
            
            try {
                bodyPixNet = await bodyPix.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    multiplier: 0.75,
                    quantBytes: 2
                });
                console.log('BodyPix –∑–∞–≥—Ä—É–∂–µ–Ω');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ BodyPix:', error);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MediaPipe
        async function initMediaPipe() {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MediaPipe...');
            
            holistic = new Holistic({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
            });

            holistic.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: true,
                smoothSegmentation: true,
                refineFaceLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            holistic.onResults(onHolisticResults);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ MediaPipe
        function onHolisticResults(results) {
            if (!gameRunning) return;

            updateTracking(results);
            updateAvatar(results);
            removeBackground(results);
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∏–Ω–≥–∞
        function updateTracking(results) {
            const trackingStatus = document.getElementById('tracking');
            
            if (results.poseLandmarks && results.poseLandmarks.length > 0) {
                trackingStatus.textContent = '–¢—Ä–µ–∫–∏–Ω–≥: –ê–∫—Ç–∏–≤–µ–Ω ‚úÖ';
                trackingStatus.style.color = '#4CAF50';
            } else {
                trackingStatus.textContent = '–¢—Ä–µ–∫–∏–Ω–≥: –ü–æ—Ç–µ—Ä—è–Ω ‚ùå';
                trackingStatus.style.color = '#f44336';
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∞–≤–∞—Ç–∞—Ä–∞
        function updateAvatar(results) {
            if (!results.poseLandmarks || !avatar) return;

            const pose = results.poseLandmarks;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            const leftShoulder = pose[11];
            const rightShoulder = pose[12];
            const leftHip = pose[23];
            const rightHip = pose[24];

            if (leftShoulder && rightShoulder && leftHip && rightHip) {
                // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä —Ç–µ–ª–∞
                const centerX = (leftShoulder.x + rightShoulder.x + leftHip.x + rightHip.x) / 4;
                const centerY = (leftShoulder.y + rightShoulder.y + leftHip.y + rightHip.y) / 4;

                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å—Ü–µ–Ω—ã
                avatarPosition.x = (centerX - 0.5) * 6; // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
                avatarPosition.y = (1 - centerY) * 3; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Y
                
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞
                avatar.position.x = THREE.MathUtils.lerp(avatar.position.x, avatarPosition.x, 0.1);
                avatar.position.y = THREE.MathUtils.lerp(avatar.position.y, avatarPosition.y, 0.1);

                // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—É–∫
                const { leftArm, rightArm } = avatar.userData;
                if (leftArm && rightArm) {
                    const leftWrist = pose[15];
                    const rightWrist = pose[16];
                    
                    if (leftWrist) {
                        leftArm.rotation.z = (leftWrist.y - leftShoulder.y) * 2;
                    }
                    if (rightWrist) {
                        rightArm.rotation.z = -(rightWrist.y - rightShoulder.y) * 2;
                    }
                }
            }
        }

        // –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞
        async function removeBackground(results) {
            if (!bodyPixNet || !videoElement) return;

            try {
                const segmentation = await bodyPixNet.segmentPerson(videoElement, {
                    flipHorizontal: false,
                    internalResolution: 'medium',
                    segmentationThreshold: 0.7
                });

                const ctx = canvasElement.getContext('2d');
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;

                // –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞
                const foregroundColor = {r: 0, g: 0, b: 0, a: 0};
                const backgroundColor = {r: 0, g: 0, b: 0, a: 0};
                const backgroundDarkeningMask = bodyPix.toMask(
                    segmentation, foregroundColor, backgroundColor
                );

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å–∫—É
                ctx.globalCompositeOperation = 'source-over';
                ctx.putImageData(backgroundDarkeningMask, 0, 0);
                ctx.globalCompositeOperation = 'source-in';
                ctx.drawImage(videoElement, 0, 0);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞:', error);
            }
        }

        // –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 1280, 
                        height: 720,
                        facingMode: 'user'
                    }
                });
                
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await holistic.send({image: videoElement});
                        },
                        width: 1280,
                        height: 720
                    });
                    camera.start();
                };
                
                return true;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', error);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.');
                return false;
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        function createGameObjects() {
            // –°–æ–∑–¥–∞–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª—ã –¥–ª—è —Å–±–æ—Ä–∞
            for (let i = 0; i < 5; i++) {
                const crystalGeometry = new THREE.OctahedronGeometry(0.2);
                const crystalMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x004444,
                    transparent: true,
                    opacity: 0.8
                });
                
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 3 + 0.5,
                    (Math.random() - 0.5) * 4
                );
                crystal.userData = { type: 'crystal', collected: false };
                scene.add(crystal);
                gameObjects.push(crystal);
            }
        }

        // –ò–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞
        function gameLogic() {
            if (!gameRunning || !avatar) return;

            // –í—Ä–∞—â–µ–Ω–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            gameObjects.forEach(obj => {
                if (obj.userData.type === 'crystal' && !obj.userData.collected) {
                    obj.rotation.y += 0.02;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∞–≤–∞—Ç–∞—Ä–æ–º
                    const distance = avatar.position.distanceTo(obj.position);
                    if (distance < 0.5) {
                        obj.userData.collected = true;
                        obj.visible = false;
                        score += 10;
                        updateScore();
                        createParticleEffect(obj.position);
                        
                        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫—Ä–∏—Å—Ç–∞–ª–ª
                        setTimeout(() => {
                            obj.position.set(
                                (Math.random() - 0.5) * 8,
                                Math.random() * 3 + 0.5,
                                (Math.random() - 0.5) * 4
                            );
                            obj.userData.collected = false;
                            obj.visible = true;
                        }, 2000);
                    }
                }
            });
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —á–∞—Å—Ç–∏—Ü
        function createParticleEffect(position) {
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${(position.x / 8 + 0.5) * window.innerWidth}px`;
                particle.style.top = `${(0.5 - position.y / 3) * window.innerHeight}px`;
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    particle.remove();
                }, 2000);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç–∞
        function updateScore() {
            document.getElementById('score').textContent = `–°—á—ë—Ç: ${score}`;
        }

        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            gameLogic();
            
            if (mixer) {
                mixer.update(0.016);
            }
            
            renderer.render(scene, camera);
        }

        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        async function startGame() {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            
            const cameraStarted = await startCamera();
            if (!cameraStarted) {
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
                return;
            }
            
            gameRunning = true;
            score = 0;
            updateScore();
            
            createGameObjects();
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('gameStatus').textContent = '–ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞!';
            
            console.log('–ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞!');
        }

        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
        async function toggleCamera() {
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
                document.getElementById('tracking').textContent = '–¢—Ä–µ–∫–∏–Ω–≥: –û—Ç–∫–ª—é—á–µ–Ω';
            } else {
                await startCamera();
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', init);
    </script>
</body>
</html>
