<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Full‑Body → 3D Аватар → Игра (чистый доступ к камере)</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root { --bg:#0b0d10; --fg:#e6ebf1; --muted:#97a3b6; --accent:#7c9cff; --ok:#35d07f; --warn:#ffcc00; --bad:#ff4d4f; }
    html,body{height:100%;}
    body{margin:0;font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; background:var(--bg); color:var(--fg);}
    header{padding:16px; display:flex; align-items:center; gap:12px; border-bottom:1px solid #1b1f26; position:sticky; top:0; z-index:5; background:linear-gradient(180deg, rgba(11,13,16,.95), rgba(11,13,16,.85)); backdrop-filter: blur(6px);}    
    h1{font-size:18px;margin:0}
    .badge{font-size:12px;color:#ccd6e4;background:#14213a;padding:4px 8px;border-radius:999px;border:1px solid #223052}
    main{display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px;}
    @media (max-width: 980px){ main{grid-template-columns: 1fr;} }
    .card{border:1px solid #1b1f26; border-radius:16px; background:#0f1217; box-shadow: 0 10px 30px rgba(0,0,0,.25);}
    .panel{padding:16px;}
    .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .col{display:flex; flex-direction:column; gap:10px}
    button{appearance:none; border-radius:14px; padding:12px 16px; border:1px solid #2a3446; background:#131a24; color:#e9eef8; cursor:pointer; font-weight:600;}
    button:hover{border-color:#3b4b67}
    button.pri{background:linear-gradient(180deg,#1a58ff,#0033cc); border-color:#2b57ff}
    button.good{background:linear-gradient(180deg,#1a9a5a,#007844); border-color:#1fb76b}
    button.warn{background:linear-gradient(180deg,#d69600,#a06f00); border-color:#ffb300}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
    .hint{color:var(--muted); font-size:13px}
    .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    details{border:1px dashed #2a3346; border-radius:12px; padding:10px 12px}
    summary{cursor:pointer}
    #stage{position:relative; min-height: 60vh; height: 72vh;}
    #three{position:absolute; inset:0; display:block; width:100%; height:100%;}
    #dbgLayer{position:absolute; right:8px; bottom:8px; width:240px; height:135px; border:1px solid #2a3346; border-radius:10px; overflow:hidden; display:none; background:#000}
    #video{width:100%; height:100%; object-fit:cover}
    #dbgCanvas{position:absolute; inset:0;}
    #hud{position:absolute; left:8px; top:8px; background:rgba(0,0,0,.45); padding:10px 12px; border-radius:12px; border:1px solid #2b3446; display:none}
    #log{white-space:pre-wrap; max-height:30vh; overflow:auto; background:#0a0d12; padding:12px; border-radius:12px; border:1px solid #1b2232}
    .kpi{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
    .kpi .box{background:#0c1117; border:1px solid #1c2230; border-radius:12px; padding:8px}
    .label{font-size:12px; color:#97a3b6}
    .value{font-size:20px; font-weight:800}
    .sep{height:1px;background:#1b1f26;margin:12px 0}
    .grid{display:grid; gap:10px}
    .tag{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2a3346; background:#121821; color:#cfd7e6}
  </style>
</head>
<body>
  <header>
    <h1>3D Аватар по полному телу + игра (после гарантированного запроса камеры)</h1>
    <span class="badge">Single‑file • HTTPS/localhost only • Safari/Chrome/Firefox</span>
  </header>

  <main>
    <section class="card panel" style="min-width:290px">
      <div class="col">
        <h2 style="margin:4px 0 0">Шаг 1 — запрашиваем камеру (чистая база)</h2>
        <p class="hint">Запускаем строго из клика. Если страница в iframe — нужен <span class="mono">allow="camera; microphone"</span>. Для iOS у видео заранее выставлены <span class="mono">playsinline</span> и <span class="mono">muted</span>.</p>
        <div class="row">
          <button id="startBtn" class="pri">1) Разрешить камеру</button>
          <button id="stopBtn" class="warn" disabled>Стоп камера</button>
        </div>
        <div id="env" class="hint mono"></div>
        <div class="sep"></div>
        
        <h2 style="margin:0">Шаг 2 — трекинг тела → 3D аватар → игра</h2>
        <p class="hint">Модули грузим <b>после</b> успешного доступа к камере: <span class="tag">TensorFlow.js</span> <span class="tag">BlazePose</span> <span class="tag">Three.js</span>.</p>
        <div class="row">
          <button id="trackBtn" class="good" disabled>2) Запустить трекинг и 3D</button>
          <button id="toggleDbgBtn" disabled>Отладка: показать камеру</button>
        </div>
        
        <div class="sep"></div>
        <div class="kpi">
          <div class="box"><div class="label">FPS рендера</div><div class="value" id="fpsR">—</div></div>
          <div class="box"><div class="label">FPS трекинга</div><div class="value" id="fpsT">—</div></div>
          <div class="box"><div class="label">Ping камер</div><div class="value" id="fpsC">—</div></div>
        </div>
        
        <div class="sep"></div>
        <details>
          <summary>Если камера не спрашивает доступ</summary>
          <ul>
            <li>Должен быть <b>HTTPS</b> или <b>localhost</b>.</li>
            <li>В Safari проверьте: Настройки → Веб‑сайты → Камера → Разрешить.</li>
            <li>Если вы в iframe — добавьте <span class="mono">allow="camera; microphone"</span> и <span class="mono">sandbox</span> без блокировок.</li>
            <li>Если однажды отказали — сайт запомнил. Зайдите в настройки сайта и разрешите.</li>
            <li>На iOS/iphone: видео с <span class="mono">playsinline</span> + <span class="mono">muted</span>, запуск из <b>клика</b>.</li>
          </ul>
        </details>
        <div class="sep"></div>
        <div id="log" class="mono" aria-live="polite"></div>
      </div>
    </section>

    <section class="card panel">
      <div id="stage">
        <canvas id="three"></canvas>
        <div id="hud" class="mono"></div>
        <div id="dbgLayer">
          <video id="video" playsinline muted autoplay></video>
          <canvas id="dbgCanvas"></canvas>
        </div>
      </div>
      <p class="hint">Совет: поставьте ноут/телефон так, чтобы вас было видно <b>целиком</b> (с головы до стоп). Держите освещение ровным.</p>
    </section>
  </main>

  <script type="module">
    // === ШАГ 0. Системные утилиты и "чистая база" ===
    const $ = (sel)=>document.querySelector(sel);
    const logEl = $('#log');
    const envEl = $('#env');
    const startBtn = $('#startBtn');
    const stopBtn = $('#stopBtn');
    const trackBtn = $('#trackBtn');
    const toggleDbgBtn = $('#toggleDbgBtn');
    const video = $('#video');
    const dbgCanvas = $('#dbgCanvas');
    const dbgCtx = dbgCanvas.getContext('2d');
    const hud = $('#hud');
    const threeCanvas = $('#three');
    const dbgLayer = $('#dbgLayer');
    let stream = null;
    let trackingStarted = false;
    let cameraOk = false;

    function log(...args){
      const msg = args.map(a => typeof a==='object'? JSON.stringify(a): String(a)).join(' ');
      console.log('[LOG]', ...args);
      logEl.textContent += `\n${new Date().toLocaleTimeString()} ${msg}`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Environment info for диагностики
    const envInfo = {
      protocol: location.protocol,
      host: location.host,
      isSecureContext: window.isSecureContext,
      ua: navigator.userAgent,
      inIframe: (()=>{ try { return window.self !== window.top; } catch{ return true; } })(),
      permissions: {}
    };

    envEl.textContent = `protocol=${envInfo.protocol} host=${envInfo.host} isSecureContext=${envInfo.isSecureContext} inIframe=${envInfo.inIframe}`;

    async function checkPermissions(){
      if (!('permissions' in navigator)) return;
      try{
        const st = await navigator.permissions.query({name:'camera'});
        envInfo.permissions.camera = st.state; // 'granted' | 'denied' | 'prompt'
        log('permissions.camera =', st.state);
      }catch(e){/* Safari не всегда разрешает */}
    }
    checkPermissions();

    function requireHttps(){
      if (!(location.protocol === 'https:' || location.hostname === 'localhost')){
        throw new Error('Нужен HTTPS или localhost — иначе браузер не даст доступ к камере.');
      }
      if (envInfo.inIframe){
        log('Страница в iframe. Убедитесь, что на iframe есть allow="camera; microphone" и sandbox не блокирует.');
      }
    }

    // === ШАГ 1. Запрос камеры строго из клика ===
    startBtn.addEventListener('click', async ()=>{
      try{
        requireHttps();
        startBtn.disabled = true;
        log('start() click');
        // Жесткие атрибуты для iOS Safari
        video.setAttribute('playsinline','');
        video.setAttribute('muted','');
        video.muted = true;
        video.autoplay = true;

        const constraints = {
          video: {
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30, max: 60 }
          },
          audio: false
        };

        const t0 = performance.now();
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        const t1 = performance.now();
        log('getUserMedia ok in', Math.round(t1 - t0), 'ms');

        video.srcObject = stream;
        await video.play();
        await new Promise(r=>setTimeout(r, 50));
        cameraOk = true;
        stopBtn.disabled = false;
        trackBtn.disabled = false;
        toggleDbgBtn.disabled = false;
        hud.style.display = 'block';

        // Обновляем KPI камера fps (примерная оценка по таймеру рисования превью)
        startCameraPing();
      }catch(err){
        startBtn.disabled = false;
        cameraOk = false;
        handleGumError(err);
      }
    });

    stopBtn.addEventListener('click', ()=>{
      if (stream){ for (const t of stream.getTracks()) t.stop(); }
      stream = null; cameraOk = false;
      stopBtn.disabled = true; trackBtn.disabled = true; toggleDbgBtn.disabled = true; startBtn.disabled = false;
      log('Камера остановлена пользователем');
    });

    toggleDbgBtn.addEventListener('click', ()=>{
      dbgLayer.style.display = dbgLayer.style.display === 'none' ? 'block' : 'none';
      toggleDbgBtn.textContent = dbgLayer.style.display === 'none' ? 'Отладка: показать камеру' : 'Отладка: скрыть камеру';
    });

    function handleGumError(err){
      console.error(err);
      const name = err && (err.name || err.toString());
      if (name === 'NotAllowedError' || name === 'SecurityError'){
        log('❌ Доступ к камере запрещён. Проверьте настройки сайта/браузера и попробуйте снова.');
      } else if (name === 'NotFoundError' || name === 'OverconstrainedError'){
        log('❌ Камера не найдена или неподходящая. Подключите камеру.');
      } else if (name === 'NotReadableError'){
        log('❌ Камера занята другой программой. Закройте её и попробуйте снова.');
      } else if (name && String(name).includes('HTTPS')){
        log('❌ Нужен HTTPS или localhost.');
      } else {
        log('❌ Ошибка getUserMedia:', err.message || err);
      }
    }

    // === KPI: FPS замеры ===
    let camPingRAF; let lastCamTS=performance.now(); let camFrames=0;
    function startCameraPing(){
      if (!cameraOk) return;
      function tick(ts){
        camFrames++; if (ts - lastCamTS > 1000){
          $('#fpsC').textContent = camFrames.toString();
          camFrames = 0; lastCamTS = ts;
        }
        camPingRAF = requestAnimationFrame(tick);
      }
      cancelAnimationFrame(camPingRAF); camPingRAF = requestAnimationFrame(tick);
    }

    // === ШАГ 2. Трекер позы + Three.js сцена и мини‑игра ===
    trackBtn.addEventListener('click', async ()=>{
      if (!cameraOk || trackingStarted) return;
      trackingStarted = true;
      trackBtn.disabled = true;
      log('Загружаем модули: tfjs + pose‑detection + three.js …');

      // Ленивая загрузка зависимостей:
      const [tf, tfwebgl, posedetection, THREE] = await Promise.all([
        import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.21.0/dist/tf-core.esm.js'),
        import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.21.0/dist/tf-backend-webgl.esm.js'),
        import('https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.0.0/dist/pose-detection.esm.js'),
        import('https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js')
      ]).catch(e=>{ log('❌ Ошибка загрузки модулей', e); throw e; });

      await tf.setBackend('webgl'); await tf.ready();
      log('TFJS backend:', tf.getBackend());

      // Настраиваем canvas для превью (dbg)
      function resizeDbg(){
        const w = 240, h = 135;
        dbgCanvas.width = w; dbgCanvas.height = h;
      }
      resizeDbg();

      // Создаём детектор полного тела (BlazePose GHUM full)
      const detector = await posedetection.createDetector(
        posedetection.SupportedModels.BlazePose,
        {
          runtime: 'tfjs',
          modelType: 'full', // full | lite | heavy
          enableSmoothing: true
        }
      );
      log('Pose detector готов');

      // === THREE.JS SCENE ===
      const scene = new THREE.Scene();
      scene.background = null; // прозрачный фон

      const camera = new THREE.PerspectiveCamera(55, threeCanvas.clientWidth/threeCanvas.clientHeight, 0.1, 100);
      camera.position.set(0, 1.6, 3.2);

      const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true, alpha: true, preserveDrawingBuffer:false });
      function resizeRenderer(){
        const {clientWidth:w, clientHeight:h} = threeCanvas;
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(w, h, false);
        camera.aspect = w/h; camera.updateProjectionMatrix();
      }
      const ro = new ResizeObserver(resizeRenderer); ro.observe(threeCanvas); resizeRenderer();

      // Свет
      const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 1.0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.4);
      dir.position.set(3, 5, 3);
      dir.castShadow = true; scene.add(dir);

      // Полупрозрачная площадка/туман для глубины
      const fog = new THREE.FogExp2(0x0b0d10, 0.12); scene.fog = fog;

      // === "Аватар" — 3D‑скелет высокого качества ===
      // Сферы‑суставы + мягкие цилиндры‑кости, поверх — тонкий мерцающий слой
      const JOINTS = [
        'nose','left_eye','right_eye','left_ear','right_ear','left_shoulder','right_shoulder','left_elbow','right_elbow','left_wrist','right_wrist','left_hip','right_hip','left_knee','right_knee','left_ankle','right_ankle','left_heel','right_heel','left_foot_index','right_foot_index'
      ];
      const BONES = [
        ['left_shoulder','right_shoulder'],
        ['left_shoulder','left_elbow'], ['left_elbow','left_wrist'],
        ['right_shoulder','right_elbow'], ['right_elbow','right_wrist'],
        ['left_hip','right_hip'],
        ['left_shoulder','left_hip'], ['right_shoulder','right_hip'],
        ['left_hip','left_knee'], ['left_knee','left_ankle'],
        ['right_hip','right_knee'], ['right_knee','right_ankle'],
        ['left_ankle','left_heel'], ['left_heel','left_foot_index'],
        ['right_ankle','right_heel'], ['right_heel','right_foot_index']
      ];

      const jointMeshes = new Map();
      const boneMeshes = [];
      const jointGeo = new THREE.SphereGeometry(0.035, 24, 24);
      const jointMat = new THREE.MeshPhysicalMaterial({ color: 0x8fb3ff, emissive:0x0, metalness: 0.4, roughness: 0.2, transmission:0.4, thickness:0.02, clearcoat:1, clearcoatRoughness:.1 });
      const glowMat = new THREE.MeshBasicMaterial({ color:0xbdd2ff, transparent:true, opacity:0.14 });

      for (const j of JOINTS){
        const core = new THREE.Mesh(jointGeo, jointMat); core.castShadow = true; core.receiveShadow = false;
        const halo = new THREE.Mesh(new THREE.SphereGeometry(0.05, 18, 18), glowMat); core.add(halo);
        scene.add(core); jointMeshes.set(j, core);
      }
      function makeBone(){
        const geo = new THREE.CylinderGeometry(0.02, 0.02, 1, 16, 1, true);
        const mat = new THREE.MeshPhysicalMaterial({color:0x4d7cff, metalness: 0.7, roughness:0.35, clearcoat:1});
        const m = new THREE.Mesh(geo, mat); m.castShadow = true; scene.add(m); return m;
      }
      for (let i=0;i<BONES.length;i++){ boneMeshes.push(makeBone()); }

      // === Мини‑игра: управляем капсулой телом, собираем сферы ===
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.5, 8, 16), new THREE.MeshStandardMaterial({color:0xB9F24B, roughness:.4, metalness:.1}));
      player.position.set(0, 0.9, 0);
      player.castShadow = true; scene.add(player);

      // Декор/уровень
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(20, 100), new THREE.MeshPhongMaterial({color:0x0c1016, emissive:0x0, shininess:30, opacity:.95, transparent:true}));
      plane.rotation.x = -Math.PI/2; plane.position.y = 0; plane.receiveShadow = true; scene.add(plane);

      const pickups = [];
      const pickGeo = new THREE.IcosahedronGeometry(0.12, 1);
      const pickMat = new THREE.MeshStandardMaterial({color:0xff66cc, emissive:0x07111a, roughness:.2, metalness:.6});
      for (let i=0;i<14;i++){
        const m = new THREE.Mesh(pickGeo, pickMat);
        m.position.set((Math.random()*2-1)*2.4, 0.6+Math.random()*1.5, -i*2 - 3);
        m.castShadow = true; scene.add(m); pickups.push(m);
      }
      const score = { value:0 };

      // Управление телом
      let jumpCooldown = 0;
      function controlByPose(pose){
        if (!pose) return;
        const k = indexByName(pose);
        const lShoulder = k('left_shoulder');
        const rShoulder = k('right_shoulder');
        const lHip = k('left_hip');
        const rHip = k('right_hip');
        const lWrist = k('left_wrist');
        const rWrist = k('right_wrist');
        const nose = k('nose');
        if (!lShoulder || !rShoulder || !lHip || !rHip) return;

        // Нормализуем X по центру тела
        const centerX = (lHip.x + rHip.x + lShoulder.x + rShoulder.x) / 4;
        const leftRight = THREE.MathUtils.clamp(-(centerX - 0.5)*4, -1.5, 1.5); // -1.5..1.5
        player.position.x += (leftRight - player.position.x) * 0.15; // сглаживание

        // Прыжок — обе руки выше плеч
        const shouldersY = (lShoulder.y + rShoulder.y)/2;
        const wristsY = Math.min(lWrist?.y ?? 1, rWrist?.y ?? 1);
        const handsUp = wristsY < shouldersY - 0.06; // руки заметно выше
        if (jumpCooldown<=0 && handsUp){ player.velocityY = 0.18; jumpCooldown = 30; }
      }

      // Физика игрока
      player.velocityY = 0;
      function updatePlayer(){
        player.velocityY -= 0.009; // гравитация
        player.position.y = Math.max(0.9, player.position.y + player.velocityY);
        if (player.position.y <= 0.9){ player.velocityY = 0; }
        if (jumpCooldown>0) jumpCooldown--;
      }

      // Обновление костей/суставов по позе
      function updateAvatar(pose){
        if (!pose) return;
        // Масштабируем нормализованные координаты (0..1) в локальное 3D пространство
        const SCALE = 2.2; // чем больше — тем крупнее аватар
        const DEPTH = 1.6; // масштаб глубины

        const k = indexByName(pose);
        for (const [name, mesh] of jointMeshes){
          const p = k(name);
          if (!p) { mesh.visible = false; continue; }
          mesh.visible = true;
          const x = (p.x - 0.5) * SCALE;
          const y = (1 - p.y) * SCALE * 1.2; // инверсия оси Y
          const z = (p.z || 0) * DEPTH;      // z от модели (отриц — ближе)
          mesh.position.set(x, y, z);
        }
        // Кости: ориентируем цилиндр от A к B
        BONES.forEach((pair, idx)=>{
          const a = jointMeshes.get(pair[0]);
          const b = jointMeshes.get(pair[1]);
          const bone = boneMeshes[idx];
          if (!a.visible || !b.visible){ bone.visible = false; return; }
          bone.visible = true;
          const va = a.position, vb = b.position;
          const mid = va.clone().add(vb).multiplyScalar(0.5);
          const dir = new THREE.Vector3().subVectors(vb, va);
          const len = dir.length();
          bone.position.copy(mid);
          bone.scale.set(1, len, 1);
          // Повернуть цилиндр вдоль направления dir
          bone.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
        });
      }

      function indexByName(pose){
        const map = new Map();
        for (const kp of pose.keypoints){ map.set(kp.name || kp.part || kp.position?.name, kp); }
        return (name)=> map.get(name);
      }

      // === Главный цикл: поза → аватар → игра ===
      let lastTrack = performance.now();
      let trackFrames=0, renderFrames=0, lastFpsT=performance.now(), lastFpsR=performance.now();

      async function tick(){
        const now = performance.now();

        // 1) ТРЕКИНГ ( ~ 30–60 Гц, по возможности )
        let pose = null;
        try{
          const est = await detector.estimatePoses(video, { flipHorizontal: true });
          pose = est && est[0] || null;
          trackFrames++;
          if (now - lastFpsT > 1000){ $('#fpsT').textContent = trackFrames.toString(); trackFrames = 0; lastFpsT = now; }
        }catch(e){ log('Ошибка трекинга:', e.message || e); }

        // 2) АВАТАР
        updateAvatar(pose);

        // 3) ИГРА — управление телом
        controlByPose(pose);
        updatePlayer();

        // Скаттер‑эффекты/сбор предметов
        for (const m of pickups){
          m.rotation.y += 0.01;
          const d = m.position.distanceTo(player.position);
          if (d < 0.45){
            score.value++;
            m.position.z -= 30; // телепорт дальше по треку
          }
        }

        renderer.render(scene, camera);
        renderFrames++;
        if (now - lastFpsR > 1000){ $('#fpsR').textContent = renderFrames.toString(); renderFrames = 0; lastFpsR = now; }

        hud.textContent = `Очки: ${score.value}`;
        requestAnimationFrame(tick);
      }

      // Старт цикла после короткой задержки (для стабильности видео размеров)
      setTimeout(()=>requestAnimationFrame(tick), 60);

      // Отладочный слой (мини‑превью камеры с рисованием ключевых точек)
      (function dbgLoop(){
        if (dbgLayer.style.display !== 'none' && video.videoWidth){
          dbgCanvas.width = video.clientWidth; dbgCanvas.height = video.clientHeight;
          dbgCtx.drawImage(video, 0, 0, dbgCanvas.width, dbgCanvas.height);
        }
        requestAnimationFrame(dbgLoop);
      })();
    });

    // Стартовое состояние: скрыть отладку
    dbgLayer.style.display = 'none';
  </script>
</body>
</html>
